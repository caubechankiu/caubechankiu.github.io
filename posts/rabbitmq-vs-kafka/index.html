<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Rabbitmq vs Kafka - caubechankiu's miscellaneous notes</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="RabbitMQ và Apache Kafka là hai hệ thống messaging phổ biến, được sử dụng rộng rãi trong các ứng dụng phân tán. Mỗi công nghệ đều có những ưu điểm và nhược điểm riêng, phù hợp với từng trường hợp sử dụng khác nhau. Trong bài viết này, chúng ta sẽ so sánh RabbitMQ và Kafka dựa trên các tiêu chí quan trọng."><meta property="og:image" content><meta property="og:url" content="https://caubechankiu.github.io/posts/rabbitmq-vs-kafka/"><meta property="og:site_name" content="caubechankiu's miscellaneous notes"><meta property="og:title" content="Rabbitmq vs Kafka"><meta property="og:description" content="RabbitMQ và Apache Kafka là hai hệ thống messaging phổ biến, được sử dụng rộng rãi trong các ứng dụng phân tán. Mỗi công nghệ đều có những ưu điểm và nhược điểm riêng, phù hợp với từng trường hợp sử dụng khác nhau. Trong bài viết này, chúng ta sẽ so sánh RabbitMQ và Kafka dựa trên các tiêu chí quan trọng."><meta property="og:locale" content="vi_VN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-04T10:35:19+07:00"><meta property="article:modified_time" content="2025-03-04T10:35:19+07:00"><meta property="article:tag" content="Message Queue"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rabbitmq vs Kafka"><meta name=twitter:description content="RabbitMQ và Apache Kafka là hai hệ thống messaging phổ biến, được sử dụng rộng rãi trong các ứng dụng phân tán. Mỗi công nghệ đều có những ưu điểm và nhược điểm riêng, phù hợp với từng trường hợp sử dụng khác nhau. Trong bài viết này, chúng ta sẽ so sánh RabbitMQ và Kafka dựa trên các tiêu chí quan trọng."><link href=https://caubechankiu.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://caubechankiu.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css></head><body><div class=content><header><div class=main><a href=https://caubechankiu.github.io/>caubechankiu's miscellaneous notes</a></div><nav></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Rabbitmq vs Kafka</h1><div class=meta>Posted on Mar 4, 2025</div></div><section class=body><p>RabbitMQ và Apache Kafka là hai hệ thống messaging phổ biến, được sử dụng rộng rãi trong các ứng dụng phân tán. Mỗi công nghệ đều có những ưu điểm và nhược điểm riêng, phù hợp với từng trường hợp sử dụng khác nhau. Trong bài viết này, chúng ta sẽ so sánh RabbitMQ và Kafka dựa trên các tiêu chí quan trọng.</p><h2 id=1-kiến-trúc-và-cơ-chế-hoạt-động>1. Kiến trúc và cơ chế hoạt động</h2><h3 id=rabbitmq>RabbitMQ</h3><p><img src=rabbitmq.png alt="Rabbitmq Architecture"></p><p>RabbitMQ là một message broker hoạt động theo mô hình message queue. Nó hỗ trợ nhiều mô hình trao đổi tin nhắn, bao gồm:</p><ul><li><strong>Point-to-Point (Queue-based)</strong>: Tin nhắn được gửi đến một hàng đợi và được xử lý bởi một consumer duy nhất.</li><li><strong>Publish-Subscribe (Exchange-based)</strong>: Tin nhắn được gửi đến một exchange, sau đó phân phối đến nhiều consumer theo các quy tắc routing.</li><li><strong>Request-Reply</strong>: Thường được sử dụng trong các hệ thống đồng bộ hóa giao tiếp.</li></ul><p>RabbitMQ lưu trữ tin nhắn tạm thời trong bộ nhớ hoặc đĩa và đảm bảo tin nhắn được xử lý ít nhất một lần (at-least-once delivery).</p><h3 id=apache-kafka>Apache Kafka</h3><p>Kafka là một hệ thống distributed event streaming, hoạt động theo mô hình publish-subscribe. Các thành phần chính của Kafka bao gồm:</p><ul><li><strong>Producer</strong>: Gửi dữ liệu vào các topic.</li><li><strong>Broker</strong>: Lưu trữ và quản lý tin nhắn.</li><li><strong>Consumer</strong>: Đọc dữ liệu từ các topic.</li><li><strong>Partition</strong>: Mỗi topic có thể được chia thành nhiều partition để tăng hiệu suất và tính sẵn sàng.</li></ul><p>Kafka lưu trữ tin nhắn theo cơ chế log-based, giúp đảm bảo tin nhắn không bị mất và có thể đọc lại nhiều lần.</p><h2 id=2-hiệu-suất-và-thông-lượng>2. Hiệu suất và thông lượng</h2><ul><li><strong>RabbitMQ</strong> phù hợp với các hệ thống yêu cầu độ trễ thấp và giao tiếp đồng bộ. Tuy nhiên, hiệu suất có thể bị giới hạn do cách hàng đợi hoạt động.</li><li><strong>Kafka</strong> có thể xử lý hàng triệu tin nhắn mỗi giây nhờ vào cơ chế lưu trữ log-based và khả năng scale out dễ dàng với partition.</li></ul><h2 id=3-độ-tin-cậy-và-đảm-bảo-tin-nhắn>3. Độ tin cậy và đảm bảo tin nhắn</h2><ul><li><strong>RabbitMQ</strong> hỗ trợ xác nhận tin nhắn (acknowledgment) và cơ chế retry nếu tin nhắn không được xử lý thành công. Nó đảm bảo tin nhắn được xử lý ít nhất một lần (at-least-once).</li><li><strong>Kafka</strong> có cơ chế lưu trữ tin nhắn lâu dài, cho phép đọc lại dữ liệu và đảm bảo tính chính xác với exactly-once semantics khi kết hợp với Kafka Streams.</li></ul><h2 id=4-khả-năng-mở-rộng>4. Khả năng mở rộng</h2><ul><li><strong>RabbitMQ</strong> có thể mở rộng bằng cách sử dụng cluster hoặc federation, nhưng hiệu suất sẽ bị giới hạn bởi kiến trúc hàng đợi.</li><li><strong>Kafka</strong> được thiết kế để scale horizontally, hỗ trợ việc mở rộng dễ dàng bằng cách thêm nhiều broker và partition.</li></ul><h2 id=5-trường-hợp-sử-dụng>5. Trường hợp sử dụng</h2><table><thead><tr><th>Tiêu chí</th><th>RabbitMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>Hệ thống xử lý sự kiện thời gian thực</td><td>❌</td><td>✅</td></tr><tr><td>Giao tiếp giữa các dịch vụ nhỏ (Microservices)</td><td>✅</td><td>❌</td></tr><tr><td>Streaming dữ liệu lớn</td><td>❌</td><td>✅</td></tr><tr><td>Xử lý dữ liệu cần đảm bảo thứ tự nghiêm ngặt</td><td>✅</td><td>❌</td></tr><tr><td>Hàng đợi công việc (Task Queue)</td><td>✅</td><td>❌</td></tr></tbody></table><h2 id=6-kết-luận>6. Kết luận</h2><ul><li><strong>Chọn RabbitMQ</strong> nếu bạn cần một hệ thống hàng đợi tin nhắn truyền thống, phù hợp với các hệ thống microservices, yêu cầu đảm bảo thứ tự xử lý tin nhắn và độ trễ thấp.</li><li><strong>Chọn Kafka</strong> nếu bạn cần xử lý lượng lớn dữ liệu theo luồng, đảm bảo tính mở rộng và khả năng lưu trữ lâu dài.</li></ul><p>Tùy vào nhu cầu cụ thể của ứng dụng, bạn có thể chọn công nghệ phù hợp hoặc kết hợp cả hai để tận dụng điểm mạnh của từng hệ thống.</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/message-queue>message queue</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/caubechankiu rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.facebook.com/trinhthevils rel=me title=Facebook><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#facebook"/></svg></a><a class=border></a></div><div class=footer-info>2025 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>