<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Consistent Hashing - caubechankiu's miscellaneous notes</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Trong các hệ thống phân tán như caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB), việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng."><meta property="og:image" content><meta property="og:url" content="https://caubechankiu.github.io/posts/consistent-hashing/"><meta property="og:site_name" content="caubechankiu's miscellaneous notes"><meta property="og:title" content="Consistent Hashing"><meta property="og:description" content="Trong các hệ thống phân tán như caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB), việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng."><meta property="og:locale" content="vi_VN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-01T10:43:32+07:00"><meta property="article:modified_time" content="2020-04-01T10:43:32+07:00"><meta property="article:tag" content="Distributed System"><meta property="article:tag" content="Load Balancer"><meta name=twitter:card content="summary"><meta name=twitter:title content="Consistent Hashing"><meta name=twitter:description content="Trong các hệ thống phân tán như caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB), việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng."><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://caubechankiu.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/archie.90f4a1321261c2df9485c29a7877582160bb95d018fefaa5f2199bccf7b169f5.css></head><body><div class=content><header><div class=main><a href=https://caubechankiu.github.io/>caubechankiu's miscellaneous notes</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/tags>Tags</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="https://unpkg.com/feather-icons@4.29.2/dist/feather-sprite.svg#sun"/></svg></span>
<script src=https://caubechankiu.github.io/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Consistent Hashing</h1><div class=meta>Posted on Apr 1, 2020</div></div><section class=body><h2 id=1-giới-thiệu>1. Giới thiệu</h2><p>Trong các hệ thống phân tán như <strong>caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB)</strong>, việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng.</p><p>Nếu sử dụng phương pháp <strong>modular hashing</strong>, việc thêm hoặc xóa một node sẽ làm thay đổi hoàn toàn cách dữ liệu được phân phối, gây ra <strong>mất cân bằng tải</strong> và <strong>di chuyển dữ liệu lớn</strong>. <strong>Consistent Hashing</strong> là một thuật toán giúp giải quyết vấn đề này một cách hiệu quả.</p><hr><h2 id=2-modular-hashing>2. Modular Hashing</h2><h3 id=21-modular-hashing-là-gì>2.1. Modular Hashing là gì?</h3><p><strong>Modular Hashing</strong> là một phương pháp đơn giản để ánh xạ dữ liệu vào các node trong hệ thống. Công thức:</p><p><code>Node = hash(key) % Số lượng node</code></p><p>Ví dụ: Nếu ta có 4 node (<code>N0</code>, <code>N1</code>, <code>N2</code>, <code>N3</code>) và dữ liệu là các user như sau</p><ul><li>Công thức: <code>Node = hash(key) % 4</code></li></ul><table><thead><tr><th>N0</th><th>N1</th><th>N2</th><th>N3</th></tr></thead><tbody><tr><td>User 0</td><td>User 1</td><td>User 2</td><td>User 3</td></tr><tr><td>User 4</td><td>User 5</td><td>User 6</td><td>User 7</td></tr></tbody></table><h3 id=22-nhược-điểm-của-modular-hashing>2.2. Nhược điểm của Modular Hashing</h3><p>✅ <strong>Ưu điểm</strong>: Dễ triển khai, tính toán nhanh.<br>❌ <strong>Nhược điểm</strong>: Khi thêm hoặc xóa một node, <strong>hầu hết dữ liệu phải di chuyển</strong>, gây ảnh hưởng lớn đến hệ thống.</p><p><strong>Ví dụ khi giảm bớt 1 node <code>N3</code>:</strong></p><ul><li>Công thức mới: <code>Node = hash(key) % 3</code></li><li>Kết quả: Các key phải ánh xạ lại do kết quả phép chia thay đổi như sau</li></ul><table><thead><tr><th>N0</th><th>N1</th><th>N2</th><th><del>N3</del></th></tr></thead><tbody><tr><td>User 0</td><td>User 1</td><td>User 2</td><td></td></tr><tr><td>User 3</td><td>User 4</td><td>User 5</td><td></td></tr><tr><td>User 6</td><td>User 7</td><td></td><td></td></tr></tbody></table><p>Như vậy chỉ số ít dữ liệu giữ nguyên còn phần lớn sẽ bị di chuyển</p><p>➡ <strong>Đây là vấn đề lớn khi hệ thống cần mở rộng hoặc thu nhỏ.</strong></p><h2 id=3-consistent-hashing-là-gì>3. Consistent Hashing là gì?</h2><p><strong>Consistent Hashing</strong> là một thuật toán giúp phân phối dữ liệu vào các node trong hệ thống sao cho <strong>khi thêm hoặc xóa một node, chỉ một phần nhỏ dữ liệu cần di chuyển</strong> (trung bình là k/n với k là tổng số lượng key, n là tổng số lượng node).</p><h3 id=31-cách-hoạt-động>3.1. Cách hoạt động</h3><p>Consistent Hashing hoạt động bằng cách ánh xạ các node trong cluster lên một vòng tròn (gọi là hash ring), trong đó một hàm hash được sử dụng để chuyển đổi các key thành số nguyên nằm trong một phạm vi nhất định. Các số nguyên này sau đó được đặt trên vòng tròn sao cho mỗi vị trí trên vòng tương ứng với một giá trị trong dãy số nguyên đó.</p><h4 id=311-build-hash-ring>3.1.1. Build Hash Ring</h4><p>Thực hiện hash từng node trong cluster thành một số nguyên nằm trong một phạm vi số được xác định trước. Phạm vi này được thiết kế dựa trên sự cân nhắc của kiến trúc sư hệ thống, tùy thuộc vào số lượng server tối đa mà hệ thống có thể mở rộng.</p><figure class=center><img src=/posts/consistent-hashing/image1.png width=500px></figure><p>Các node s0, s1, s2, s3 được đặt trên vòng tròn như hình trên, lưu ý trên thực tế thì các node sẽ không phân bố đều trên vòng tròn như vậy.</p><h4 id=312-lưu-dữ-liệu-vào-node>3.1.2. Lưu dữ liệu vào node</h4><p>Khi một key (dữ liệu) cần được lưu, hệ thống tính giá trị hash của key và đặt nó lên vòng tròn. Dữ liệu sẽ được gán cho <strong>node gần nhất theo chiều kim đồng hồ</strong>.</p><figure class=center><img src=/posts/consistent-hashing/image2.png width=500px></figure><p>Dữ liệu k0 được lưu ở s0 và tương tự k1 -> s1, k2 -> s2, k3 -> s3</p><h4 id=313-xử-lý-khi-thêm--xóa-node>3.1.3. Xử lý khi thêm / xóa node</h4><ul><li><strong>Thêm node</strong>: Chỉ dữ liệu thuộc về node kế tiếp (theo chiều kim đồng hồ) bị ảnh hưởng.</li></ul><figure class=center><img src=/posts/consistent-hashing/image3.png width=500px></figure><p>Khi ta thêm node s4, chỉ những dữ liệu nằm giữa s3 và s4 trước đây được lưu ở s0 thì sẽ cần chuyển sang s4, còn lại các dữ liệu khác thì được giữ nguyên</p><ul><li><strong>Xóa node</strong>: Dữ liệu của node bị xóa sẽ được chuyển sang node kế tiếp.</li></ul><figure class=center><img src=/posts/consistent-hashing/image4.png width=500px></figure><p>Khi node s1 bị xoá, chỉ những dữ liệu nằm giữa s0 và s1 trước đây được lưu ở s1 thì sẽ cần chuyển sang s2, còn lại các dữ liệu khác thì được giữ nguyên</p><h3 id=32-virtual-node-vnode>3.2 Virtual Node (Vnode)</h3><p>Trên thực tế trong đa số trường hợp, các node sẽ không phân bố đều trên vòng tròn mà sẽ phân bố không đồng đều như hình dưới đây.</p><figure class=center><img src=/posts/consistent-hashing/image5.png width=500px></figure><p>Trong trường hợp này, dữ liệu sẽ không được phân bố đồng đều lên các node mà node s2 sẽ chứa nhiều dữ liệu nhất, do đó nó cũng sẽ phải gánh nhiều tải hơn so với các node còn lại</p><p>Để giải quyết vấn đề này, chúng ta sẽ thực hiện hash và thêm nhiều các Node ảo (virtual node) vào vòng tròn một cách ngẫu nhiên. Mỗi node ảo sẽ liên kết đến 1 node thật. Số lượng node ảo bao nhiêu cũng cần cân nhắc, phụ thuộc các yếu tố sau:</p><ul><li>Số vnode càng nhiều, dữ liệu càng được phân phối đều hơn, tránh tình trạng một node phải xử lý nhiều hơn node khác.</li><li>Tuy nhiên, quá nhiều vnode có thể gây quá tải cho thuật toán tìm kiếm node, ảnh hưởng đến hiệu suất hệ thống.</li><li>Quy tắc chung có thể áp dụng<ul><li>Ít hơn 10 node thật → 100 - 500 vnode mỗi node thật.</li><li>10 - 100 node thật → 50 - 200 vnode mỗi node thật.</li><li>Hơn 100 node thật → 10 - 50 vnode mỗi node thật.</li></ul></li></ul><figure class=center><img src=/posts/consistent-hashing/image6.png width=500px></figure><p>Ví dụ này ta có 3 node thật, mỗi node thật có thêm 2 node ảo. Như vậy data đã được phân bố đều hơn trên 2 node thật.</p><h3 id=33-ứng-dụng-thực-tế-của-consistent-hashing>3.3 Ứng dụng thực tế của Consistent Hashing</h3><ul><li>Distributed Caching (Memcached, Redis Cluster)<ul><li>Khi có nhiều node cache (Redis, Memcached), Consistent Hashing giúp ánh xạ key vào node cache tương ứng.</li><li>Khi thêm/xóa node cache, chỉ một phần nhỏ dữ liệu bị ảnh hưởng, tránh cache miss hàng loạt.</li></ul></li><li>Distributed Databases (Cassandra, DynamoDB)<ul><li>Trong các database phân tán (NoSQL như DynamoDB, Cassandra), Consistent Hashing giúp định tuyến dữ liệu vào đúng shard.</li><li>Khi thêm/xóa node, chỉ một phần dữ liệu được di chuyển.</li></ul></li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/distributed-system>distributed system</a></li><li><a href=/tags/load-balancer>load balancer</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/caubechankiu rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.facebook.com/trinhthevils rel=me title=Facebook><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#facebook"/></svg></a><a class=border></a></div><div class=footer-info>2025 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>