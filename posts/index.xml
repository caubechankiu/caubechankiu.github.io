<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on caubechankiu's miscellaneous notes</title><link>https://caubechankiu.github.io/posts/</link><description>Recent content in Posts on caubechankiu's miscellaneous notes</description><generator>Hugo</generator><language>vi-VN</language><copyright>© caubechankiu</copyright><lastBuildDate>Thu, 21 Dec 2023 09:47:31 +0700</lastBuildDate><atom:link href="https://caubechankiu.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Transaction Outbox Pattern</title><link>https://caubechankiu.github.io/posts/transaction-outbox-pattern/</link><pubDate>Thu, 21 Dec 2023 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/transaction-outbox-pattern/</guid><description>Transaction Outbox Pattern: Giải pháp đảm bảo tính nhất quán trong hệ thống phân tán</description></item><item><title>Rate Limiting</title><link>https://caubechankiu.github.io/posts/rate-limiting/</link><pubDate>Fri, 17 Dec 2021 23:40:15 +0700</pubDate><guid>https://caubechankiu.github.io/posts/rate-limiting/</guid><description>Rate Limiting (giới hạn tốc độ truy cập) là một kỹ thuật kiểm soát số lượng request mà một client có thể gửi đến một hệ thống trong một khoảng thời gian nhất định.</description></item><item><title>CAP Theorem</title><link>https://caubechankiu.github.io/posts/cap-theorem/</link><pubDate>Fri, 02 Apr 2021 10:43:32 +0700</pubDate><guid>https://caubechankiu.github.io/posts/cap-theorem/</guid><description>Hiểu đúng về sự đánh đổi trong hệ thống phân tán. Định lý CAP (CAP Theorem) là một nguyên tắc quan trọng trong lĩnh vực hệ thống phân tán, được nhà khoa học máy tính Eric Brewer đề xuất vào năm 2000</description></item><item><title>Circuit Breaker and Retry</title><link>https://caubechankiu.github.io/posts/circuit-breaker-and-retry/</link><pubDate>Sat, 20 Feb 2021 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/circuit-breaker-and-retry/</guid><description>Circuit breaker và retry là hai cơ chế quan trọng giúp tăng cường độ tin cậy và khả năng chịu lỗi của hệ thống.</description></item><item><title>Idempotency</title><link>https://caubechankiu.github.io/posts/idempotency/</link><pubDate>Tue, 09 Feb 2021 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/idempotency/</guid><description>Tính bất biến là gì và làm thế nào để sử dụng nó một cách hợp lý</description></item><item><title>Bloom Filter</title><link>https://caubechankiu.github.io/posts/bloom-filter/</link><pubDate>Wed, 14 Oct 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/bloom-filter/</guid><description>Nếu bạn từng nghe đến các cấu trúc dữ liệu như &lt;strong>Hash Table&lt;/strong> hay &lt;strong>Binary Search Tree&lt;/strong>, thì &lt;strong>Bloom Filter&lt;/strong> có thể là một khái niệm thú vị tiếp theo để khám phá.</description></item><item><title>Consistent Hashing</title><link>https://caubechankiu.github.io/posts/consistent-hashing/</link><pubDate>Wed, 01 Apr 2020 10:43:32 +0700</pubDate><guid>https://caubechankiu.github.io/posts/consistent-hashing/</guid><description>Trong các hệ thống phân tán như caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB), việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng.</description></item><item><title>Optimistic Lock vs Pessimistic Lock</title><link>https://caubechankiu.github.io/posts/optimistic-lock-vs-pessimistic-lock/</link><pubDate>Wed, 04 Mar 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/optimistic-lock-vs-pessimistic-lock/</guid><description>Trong quản lý giao dịch và cạnh tranh truy cập dữ liệu, có hai chiến lược chính để kiểm soát tính nhất quán: &lt;strong>Optimistic Lock&lt;/strong> và &lt;strong>Pessimistic Lock&lt;/strong>. Mỗi loại có cách tiếp cận khác nhau trong việc xử lý xung đột dữ liệu. Bài viết này sẽ phân tích chi tiết hai loại lock này, đồng thời giải thích hai dạng của &lt;strong>Pessimistic Lock&lt;/strong> là &lt;strong>Shared Lock&lt;/strong> và &lt;strong>Exclusive Lock&lt;/strong>.</description></item><item><title>Session vs Jwt</title><link>https://caubechankiu.github.io/posts/session-vs-jwt/</link><pubDate>Sat, 01 Feb 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/session-vs-jwt/</guid><description>Session-based authentication vs JSON Web Tokens (JWTs)</description></item><item><title>Distributed ID generator</title><link>https://caubechankiu.github.io/posts/distributed-id-generator/</link><pubDate>Sat, 25 Jan 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/distributed-id-generator/</guid><description>Nguồn mình copy nguyên văn ở &lt;a href="https://zalopay-oss.github.io/go-advanced/ch5-distributed-system/ch5-01-dist-id.html">zalo-go-advanced&lt;/a> và không sửa gì cả. Trong bài viết gốc còn nhiều kiến thức thú vị hơn. Đôi khi chúng ta cần tạo ra một ID tương tự như ID tăng tự động của MySQL và có tính chất không được trùng lặp. Chúng ta có thể sử dụng ID để hỗ trợ các ngữ cảnh trong kinh doanh. Điển hình, khi có chương trình khuyến mãi trong thương mại điện tử, một số lượng lớn đơn đặt hàng sẽ tràn vào hệ thống trong một khoảng thời gian ngắn, tạo ra khoảng 10 ngàn đơn mỗi giây, mỗi đơn sẽ tương ứng với một ID định danh.</description></item><item><title>Concurrency vs Parallelism</title><link>https://caubechankiu.github.io/posts/concurrency-parallelism/</link><pubDate>Mon, 20 Jan 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/concurrency-parallelism/</guid><description>Mô hình lập trình đồng thời và lập trình song song</description></item></channel></rss>