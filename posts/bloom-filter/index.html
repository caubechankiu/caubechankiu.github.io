<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Bloom Filter - caubechankiu's miscellaneous notes</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Nếu bạn từng nghe đến các cấu trúc dữ liệu như Hash Table hay Binary Search Tree, thì Bloom Filter có thể là một khái niệm thú vị tiếp theo để khám phá."><meta property="og:image" content><meta property="og:url" content="https://caubechankiu.github.io/posts/bloom-filter/"><meta property="og:site_name" content="caubechankiu's miscellaneous notes"><meta property="og:title" content="Bloom Filter"><meta property="og:description" content="Nếu bạn từng nghe đến các cấu trúc dữ liệu như Hash Table hay Binary Search Tree, thì Bloom Filter có thể là một khái niệm thú vị tiếp theo để khám phá."><meta property="og:locale" content="vi_VN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-14T09:47:31+07:00"><meta property="article:modified_time" content="2020-10-14T09:47:31+07:00"><meta property="article:tag" content="Algorithm"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bloom Filter"><meta name=twitter:description content="Nếu bạn từng nghe đến các cấu trúc dữ liệu như Hash Table hay Binary Search Tree, thì Bloom Filter có thể là một khái niệm thú vị tiếp theo để khám phá."><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://caubechankiu.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/archie.90f4a1321261c2df9485c29a7877582160bb95d018fefaa5f2199bccf7b169f5.css></head><body><div class=content><header><div class=main><a href=https://caubechankiu.github.io/>caubechankiu's miscellaneous notes</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/tags>Tags</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="https://unpkg.com/feather-icons@4.29.2/dist/feather-sprite.svg#sun"/></svg></span>
<script src=https://caubechankiu.github.io/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Bloom Filter</h1><div class=meta>Posted on Oct 14, 2020</div></div><section class=body><p>Nếu bạn từng nghe đến các cấu trúc dữ liệu như <strong>Hash Table</strong> hay <strong>Binary Search Tree</strong>, thì <strong>Bloom Filter</strong> có thể là một khái niệm thú vị tiếp theo để khám phá. Bloom Filter không phải là một cấu trúc dữ liệu thông thường dùng để lưu trữ và truy xuất dữ liệu chính xác, mà là một công cụ xác suất được thiết kế để kiểm tra xem một phần tử có thuộc một tập hợp hay không. Với hiệu suất cao và khả năng tiết kiệm bộ nhớ, Bloom Filter đã trở thành một phần không thể thiếu trong nhiều hệ thống lớn như cơ sở dữ liệu, mạng, và thậm chí cả blockchain. Hãy cùng tìm hiểu chi tiết về nó!</p><h2 id=bloom-filter-là-gì>Bloom Filter là gì?</h2><p><strong>Bloom Filter</strong> là một cấu trúc dữ liệu xác suất do Burton Howard Bloom đề xuất vào năm 1970. Nó được thiết kế để trả lời câu hỏi: <strong>&ldquo;Phần tử này có nằm trong tập hợp không?&rdquo;</strong> với tốc độ nhanh và sử dụng rất ít bộ nhớ. Tuy nhiên, nó không hoàn toàn chính xác 100% - điều này có nghĩa là đôi khi nó có thể trả lời &ldquo;có&rdquo; trong khi phần tử thực sự không tồn tại (<em>false positive</em>), nhưng nó sẽ không bao giờ trả lời &ldquo;không&rdquo; khi phần tử thực sự có mặt (không có <em>false negative</em>).</p><p>Bloom Filter thường được biểu diễn dưới dạng một <strong>mảng bit</strong> (<em>bit array</em>) với kích thước cố định, cùng với một số <strong>hàm băm</strong> (<em>hash functions</em>). Thay vì lưu trữ toàn bộ phần tử như các cấu trúc dữ liệu khác, nó chỉ ghi lại &ldquo;dấu vết&rdquo; của phần tử thông qua các vị trí bit được bật lên (từ 0 thành 1).</p><h2 id=cách-bloom-filter-hoạt-động>Cách Bloom Filter hoạt động</h2><p>Hãy tưởng tượng bạn có một danh sách email và muốn kiểm tra nhanh xem một email cụ thể có trong danh sách hay không mà không cần duyệt qua toàn bộ danh sách. Bloom Filter hoạt động theo hai bước chính: <strong>thêm phần tử</strong> và <strong>kiểm tra phần tử</strong>.</p><h3 id=1-thêm-phần-tử-insertion>1. Thêm phần tử (Insertion)</h3><ul><li>Khi bạn muốn thêm một phần tử (ví dụ: &ldquo;<a href=mailto:email@example.com>email@example.com</a>&rdquo;) vào Bloom Filter:<ol><li>Phần tử được đưa qua <strong>k hàm băm</strong> (<em>hash functions</em>), mỗi hàm sẽ trả về một chỉ số tương ứng trong mảng bit.</li><li>Tại mỗi chỉ số này, bit tương ứng trong mảng sẽ được đặt thành <strong>1</strong> (nếu chưa là 1).</li></ol></li><li><strong>Ví dụ</strong>: Nếu bạn có 3 hàm băm và mảng bit dài 10, thêm &ldquo;<a href=mailto:email@example.com>email@example.com</a>&rdquo; có thể đặt các bit ở vị trí 2, 5, và 8 thành 1.</li></ul><h3 id=2-kiểm-tra-phần-tử-query>2. Kiểm tra phần tử (Query)</h3><ul><li>Khi kiểm tra xem một phần tử có trong tập hợp hay không:<ol><li>Phần tử được đưa qua cùng <strong>k hàm băm</strong> để lấy các chỉ số.</li><li>Kiểm tra từng bit tại các chỉ số đó:<ul><li>Nếu <strong>tất cả các bit đều là 1</strong>, Bloom Filter trả về &ldquo;có thể có&rdquo; (<em>possibly present</em>).</li><li>Nếu <strong>ít nhất một bit là 0</strong>, phần tử chắc chắn không có trong tập hợp.</li></ul></li></ol></li><li><strong>Lưu ý</strong>: &ldquo;Có thể có&rdquo; không đảm bảo 100% phần tử tồn tại, vì các bit này có thể đã được bật bởi các phần tử khác.</li></ul><h3 id=ví-dụ-minh-họa>Ví dụ minh họa</h3><p>Giả sử bạn có Bloom Filter với mảng bit 10 phần tử (ban đầu đều là 0) và 3 hàm băm:</p><ul><li>Thêm &ldquo;ribeye&rdquo;: Hàm băm trả về vị trí 1, 3 và 4 → mảng bit: <code>[0, 1, 0, 1, 1, 0, 0, 0, 0, 0]</code>.</li><li>Thêm &ldquo;potato&rdquo;: Hàm băm trả về vị trí 0, 4 và 8 → mảng bit: <code>[1, 1, 0, 1, 1, 0, 0, 0, 1, 0]</code>.</li><li>Kiểm tra &ldquo;pork chop&rdquo;: Hàm băm trả về 0, 5 và 8.<ul><li>Vị trí 0 và 8 = 1 (OK), nhưng vị trí 5 = 0 → &ldquo;pork chop&rdquo; chắc chắn không có.<figure class=center><img src=/posts/bloom-filter/image1.png width=400px></figure></li></ul></li><li>Kiểm tra &ldquo;ribeye&rdquo;: Hàm băm trả về 1, 3 và 4:<ul><li>Vị trí 1, 3 và 4 = 1 → &ldquo;ribeye&rdquo; có thể có (thực tế là có).<figure class=center><img src=/posts/bloom-filter/image2.png width=400px></figure></li></ul></li><li>Kiểm tra &ldquo;lemon&rdquo;: Hàm băm trả về 1, 4 và 8:<ul><li>Vị trí 1, 4 và 8 = 1 → &ldquo;lemon&rdquo; có thể có (dù thực tế là không có) → <em>false positive</em><figure class=center><img src=/posts/bloom-filter/image3.png width=400px></figure></li></ul></li></ul><h2 id=công-thức-và-thông-số-quan-trọng>Công thức và thông số quan trọng</h2><p>Bloom Filter có một số thông số quan trọng ảnh hưởng đến hiệu suất:</p><ul><li><strong>m</strong>: Kích thước mảng bit (số bit).</li><li><strong>n</strong>: Số phần tử dự kiến thêm vào.</li><li><strong>k</strong>: Số hàm băm.</li><li><strong>P</strong>: Xác suất <em>false positive</em> (sai dương).</li></ul><p>Xác suất <em>false positive</em> có thể được tính gần đúng bằng công thức:</p><p>$$
P = \left(1 - e^{-kn/m} \right)^k
$$</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/algorithm>algorithm</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/caubechankiu rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.facebook.com/trinhthevils rel=me title=Facebook><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#facebook"/></svg></a><a class=border></a></div><div class=footer-info>2025 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>