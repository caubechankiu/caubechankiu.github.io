<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>HTTPS Hoạt Động Như Thế Nào? - caubechankiu's miscellaneous notes</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Tìm hiểu cách thức hoạt động của HTTPS, từ TLS handshake đến mã hóa dữ liệu, và tại sao hầu hết các website hiện nay đều yêu cầu HTTPS."><meta property="og:image" content><meta property="og:url" content="https://caubechankiu.github.io/posts/how-does-https-work/"><meta property="og:site_name" content="caubechankiu's miscellaneous notes"><meta property="og:title" content="HTTPS Hoạt Động Như Thế Nào?"><meta property="og:description" content="Tìm hiểu cách thức hoạt động của HTTPS, từ TLS handshake đến mã hóa dữ liệu, và tại sao hầu hết các website hiện nay đều yêu cầu HTTPS."><meta property="og:locale" content="vi_VN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-05T00:00:00+00:00"><meta property="article:tag" content="HTTPS"><meta property="article:tag" content="TLS"><meta property="article:tag" content="Security"><meta property="article:tag" content="Web"><meta property="article:tag" content="Encryption"><meta name=twitter:card content="summary"><meta name=twitter:title content="HTTPS Hoạt Động Như Thế Nào?"><meta name=twitter:description content="Tìm hiểu cách thức hoạt động của HTTPS, từ TLS handshake đến mã hóa dữ liệu, và tại sao hầu hết các website hiện nay đều yêu cầu HTTPS."><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://caubechankiu.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/archie.90f4a1321261c2df9485c29a7877582160bb95d018fefaa5f2199bccf7b169f5.css></head><body><div class=content><header><div class=main><a href=https://caubechankiu.github.io/>caubechankiu's miscellaneous notes</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/tags>Tags</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="https://unpkg.com/feather-icons@4.29.2/dist/feather-sprite.svg#sun"/></svg></span>
<script src=https://caubechankiu.github.io/js/themetoggle.js></script></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>HTTPS Hoạt Động Như Thế Nào?</h1><div class=meta>Posted on Oct 5, 2024</div></div><section class=body><h1 id=https-hoạt-động-như-thế-nào>HTTPS Hoạt Động Như Thế Nào?</h1><p>Ngày nay, hầu hết các website đều yêu cầu HTTPS. Vậy HTTPS hoạt động như thế nào? Chúng ta sẽ trả lời câu hỏi này trong bài viết này.</p><h2 id=vấn-đề-với-http-thông-thường>Vấn Đề Với HTTP Thông Thường</h2><p>Không có HTTPS, việc giao tiếp giữa trình duyệt và máy chủ diễn ra dưới dạng văn bản thuần túy. Điều này có nghĩa là mật khẩu bạn nhập hoặc số thẻ tín dụng bạn gửi qua internet có thể được đọc bởi bất kỳ ai có khả năng chặn nó.</p><h2 id=https-là-gì>HTTPS Là Gì?</h2><p>HTTPS được thiết kế để giải quyết vấn đề này - làm cho dữ liệu được gửi qua Internet không thể đọc được bởi bất kỳ ai khác ngoài người gửi và người nhận.</p><p>HTTPS là một phần mở rộng của giao thức HTTP. Với HTTPS, dữ liệu được gửi dưới dạng mã hóa bằng cách sử dụng một thứ gọi là TLS. TLS là viết tắt của Transport Layer Security (Bảo mật tầng vận chuyển).</p><p>Nếu dữ liệu được mã hóa bị hacker chặn, tất cả những gì họ có thể thấy chỉ là dữ liệu rối loạn.</p><p><img src=image.png alt=https></p><h2 id=https--http--tls>HTTPS = HTTP + TLS</h2><p>Điều quan trọng cần hiểu là HTTPS thực chất chỉ là HTTP chạy trên nền tảng TLS. TLS hoạt động như một lớp bảo mật nằm giữa tầng ứng dụng (HTTP) và tầng vận chuyển (TCP).</p><p>Mô hình này không chỉ áp dụng cho HTTP mà còn cho nhiều giao thức khác:</p><ul><li><strong>FTP và FTPS</strong>: File Transfer Protocol thông thường (FTP) truyền dữ liệu dưới dạng văn bản thuần túy, trong khi FTPS (FTP over TLS/SSL) mã hóa toàn bộ quá trình truyền file</li><li><strong>SMTP và SMTPS</strong>: Simple Mail Transfer Protocol dùng để gửi email, SMTPS là phiên bản bảo mật với TLS</li><li><strong>RTMP và RTMPS</strong>: Real-Time Messaging Protocol dùng cho streaming video, RTMPS là phiên bản mã hóa</li><li><strong>LDAP và LDAPS</strong>: Lightweight Directory Access Protocol dùng để truy cập thông tin thư mục, LDAPS là phiên bản an toàn</li></ul><p>Nguyên tắc chung là: <strong>Giao thức gốc + TLS = Phiên bản bảo mật</strong>. TLS cung cấp ba tính năng chính:</p><ol><li><strong>Mã hóa</strong>: Dữ liệu không thể đọc được nếu bị chặn</li><li><strong>Xác thực</strong>: Đảm bảo bạn đang giao tiếp với đúng máy chủ</li><li><strong>Toàn vẹn</strong>: Dữ liệu không bị thay đổi trong quá trình truyền</li></ol><h2 id=cách-thức-hoạt-động-của-tls-handshake>Cách Thức Hoạt Động Của TLS Handshake</h2><p>Hãy xem xét cách thức hoạt động của TLS handshake. Có một số bước:</p><h3 id=bước-1-thiết-lập-kết-nối-tcp>Bước 1: Thiết Lập Kết Nối TCP</h3><p>Giống như trong trường hợp HTTP, trình duyệt thiết lập kết nối TCP với máy chủ.</p><h3 id=bước-2-client-hello>Bước 2: Client Hello</h3><p>Đây là nơi TLS handshake bắt đầu. Trình duyệt gửi một thông điệp &ldquo;client hello&rdquo; đến máy chủ. Trong thông điệp Hello này, trình duyệt thông báo cho máy chủ những điều sau:</p><ol><li><strong>Phiên bản TLS</strong> mà nó có thể hỗ trợ - có thể là TLS 1.2, TLS 1.3, v.v.</li><li><strong>Cipher Suite</strong> mà nó hỗ trợ - Cipher Suite là một tập hợp các thuật toán mã hóa được sử dụng để mã hóa dữ liệu.</li></ol><h3 id=bước-3-server-hello-và-certificate>Bước 3: Server Hello và Certificate</h3><p>Sau khi nhận được client hello, máy chủ được chọn Cipher Suite và phiên bản TLS để sử dụng dựa trên các tùy chọn mà nó nhận được từ client. Nó gửi những thông tin này trong thông điệp &ldquo;server hello&rdquo; trở lại cho client.</p><p>Máy chủ sau đó gửi certificate (chứng chỉ) cho client. Certificate bao gồm nhiều thứ khác nhau, một trong những điều quan trọng là public key (khóa công khai) của máy chủ.</p><p>Trước khi sử dụng certificate, client phải kiểm tra xem certificate này có đáng tin cậy hay không. <strong>Bước này cực kỳ quan trọng</strong> vì nếu bỏ qua, hệ thống sẽ dễ bị tấn công Man-in-the-Middle (MITM).</p><h3 id=nguy-cơ-mitm-man-in-the-middle-attack-khi-không-kiểm-tra-certificate>Nguy Cơ MITM (Man in the Middle) Attack Khi Không Kiểm Tra Certificate</h3><p>Nếu client không xác minh certificate của server, kẻ tấn công có thể thực hiện MITM attack như sau:</p><ol><li><p><strong>Kẻ tấn công đặt mình ở giữa</strong>: Hacker định vị mình giữa client và server thật (ví dụ: qua WiFi công cộng không an toàn)</p></li><li><p><strong>Tạo certificate giả</strong>: Kẻ tấn công tạo certificate giả mạo cho website đích và gửi cho client</p></li><li><p><strong>Client chấp nhận certificate giả</strong>: Nếu không kiểm tra, client sẽ thiết lập kết nối TLS với kẻ tấn công thay vì server thật</p></li><li><p><strong>Kẻ tấn công trở thành &ldquo;proxy&rdquo;</strong>:</p><ul><li>Client gửi dữ liệu mã hóa cho kẻ tấn công (tưởng là server thật)</li><li>Kẻ tấn công giải mã, đọc/sửa đổi dữ liệu, rồi mã hóa lại gửi cho server thật</li><li>Server thật phản hồi, kẻ tấn công lại giải mã, đọc/sửa, rồi gửi về client</li></ul></li><li><p><strong>Hậu quả</strong>: Kẻ tấn công có thể đọc mọi thông tin nhạy cảm (mật khẩu, thẻ tín dụng) và thậm chí sửa đổi nội dung website</p></li></ol><p>Đây chính là lý do tại sao việc kiểm tra certificate là bước không thể thiếu trong HTTPS. Quá trình kiểm tra bao gồm:</p><ol><li><p><strong>Kiểm tra Certificate Authority (CA)</strong>: Client xác minh rằng certificate được ký bởi một Certificate Authority đáng tin cậy thông qua chuỗi tin cậy (chain of trust):</p><ul><li><strong>Root CA</strong>: Trình duyệt có sẵn danh sách các Root CA đáng tin cậy được cài đặt từ trước (như Let&rsquo;s Encrypt, DigiCert, Comodo)</li><li><strong>Intermediate CA</strong>: Certificate của website thường được ký bởi Intermediate CA, không phải trực tiếp bởi Root CA</li><li><strong>Xác minh chữ ký số</strong>: Client sử dụng public key của CA để xác minh chữ ký số trên certificate của website</li><li><strong>Chuỗi xác thực</strong>: Client theo dõi chuỗi từ certificate của website → Intermediate CA → Root CA để đảm bảo tính hợp lệ</li></ul></li><li><p><strong>Kiểm tra tên miền</strong>: Client đảm bảo rằng tên miền trong certificate khớp với tên miền của website mà nó đang truy cập.</p></li><li><p><strong>Kiểm tra thời hạn</strong>: Client xác minh rằng certificate chưa hết hạn và đã có hiệu lực.</p></li></ol><p>Nếu bất kỳ bước kiểm tra nào thất bại, trình duyệt sẽ hiển thị cảnh báo bảo mật cho người dùng.</p><p>Client sử dụng public key trong một thứ gọi là mã hóa bất đối xứng (asymmetric encryption). Trong mã hóa bất đối xứng, một phần dữ liệu được mã hóa bằng public key chỉ có thể được giải mã bằng private key (khóa riêng tư).</p><p>Điều này kết thúc bước hai - giai đoạn hello của TLS handshake. Tại thời điểm này, client có certificate của máy chủ, và client và máy chủ đã thống nhất về phiên bản TLS và Cipher Suite để sử dụng.</p><h3 id=bước-4-trao-đổi-khóa>Bước 4: Trao Đổi Khóa</h3><p>Bây giờ đến bước ba - đây là bước mà client và máy chủ đưa ra một khóa mã hóa chung để sử dụng để mã hóa dữ liệu.</p><p>Và đây là nơi mã hóa bất đối xứng lại xuất hiện. Với mã hóa bất đối xứng, dữ liệu được mã hóa ở phía client bằng public key từ máy chủ chỉ có thể được giải mã bởi máy chủ. Đây là cách client gửi khóa mã hóa một cách an toàn đến máy chủ qua internet rộng mở.</p><p>Tất cả điều này được thực hiện trong thông điệp &ldquo;client key exchange&rdquo;. Chi tiết chính xác thay đổi tùy thuộc vào Cipher Suite được sử dụng. Ở đây chúng ta sử dụng RSA làm ví dụ vì nó dễ hiểu nhất.</p><h3 id=ví-dụ-với-rsa>Ví Dụ Với RSA</h3><p>Với RSA, client tạo ra một khóa mã hóa (còn gọi là session key), mã hóa nó bằng public key của máy chủ, và gửi session key đã mã hóa đến máy chủ qua Internet.</p><p>Máy chủ nhận session key đã mã hóa và giải mã nó bằng private key của mình. Bây giờ cả hai bên đều giữ session key.</p><h3 id=bước-5-giao-tiếp-mã-hóa>Bước 5: Giao Tiếp Mã Hóa</h3><p>Đây là nơi họ bước vào bước 4 của TLS handshake, nơi họ sử dụng session key và Cipher Suite đã thống nhất để gửi dữ liệu mã hóa qua lại trong một kênh hai chiều an toàn.</p><p><img src=image-1.png alt=https></p><h2 id=tại-sao-không-chỉ-sử-dụng-mã-hóa-bất-đối-xứng>Tại Sao Không Chỉ Sử Dụng Mã Hóa Bất Đối Xứng?</h2><p>Bây giờ bạn có thể hỏi tại sao chúng ta không chỉ sử dụng mã hóa bất đối xứng cho mọi thứ? Tại sao lại chuyển sang mã hóa đối xứng?</p><p>Lý do chính là mã hóa bất đối xứng tốn kém về mặt tính toán. Nó không thực sự phù hợp cho việc truyền dữ liệu số lượng lớn.</p><h2 id=rsa-vs-diffie-hellman>RSA vs Diffie-Hellman</h2><p>Trong ví dụ của tôi sử dụng RSA cho mã hóa bất đối xứng để trao đổi session key đối xứng một cách an toàn. Một lần nữa, tôi chọn RSA vì nó dễ hiểu.</p><p>Tuy nhiên, mã hóa bất đối xứng không phải là cách duy nhất để chia sẻ session key giữa client và máy chủ. Thực tế, trong TLS 1.3, RSA không còn được hỗ trợ như một phương pháp trao đổi khóa.</p><p>Diffie-Hellman là cách phổ biến hơn ngày nay để trao đổi session key. Diffie-Hellman phức tạp, nhưng tóm lại, nó sử dụng một số toán học nâng cao liên quan đến các số nguyên tố lớn để tạo ra một session key chung mà không bao giờ truyền public key qua mạng.</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/https>HTTPS</a></li><li><a href=/tags/tls>TLS</a></li><li><a href=/tags/security>Security</a></li><li><a href=/tags/web>Web</a></li><li><a href=/tags/encryption>Encryption</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/caubechankiu rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.facebook.com/trinhthevils rel=me title=Facebook><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#facebook"/></svg></a><a class=border></a></div><div class=footer-info>2025 © caubechankiu | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>