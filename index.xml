<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>caubechankiu's miscellaneous notes</title><link>https://caubechankiu.github.io/</link><description>Recent content on caubechankiu's miscellaneous notes</description><generator>Hugo</generator><language>vi-VN</language><copyright>© caubechankiu</copyright><lastBuildDate>Tue, 05 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://caubechankiu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Man-in-the-Middle (MITM) Attack</title><link>https://caubechankiu.github.io/posts/man-in-the-middle-attack/</link><pubDate>Tue, 05 Nov 2024 00:00:00 +0000</pubDate><guid>https://caubechankiu.github.io/posts/man-in-the-middle-attack/</guid><description>&lt;h1 id="man-in-the-middle-mitm-kẻ-nghe-trộm-vô-hình-đang-rình-rập-dữ-liệu-của-bạn">Man-in-the-Middle (MITM): Kẻ Nghe Trộm Vô Hình Đang Rình Rập Dữ Liệu Của Bạn&lt;/h1>
&lt;p>Nếu bạn đã từng kết nối Wi-Fi ở quán cà phê, sân bay, hoặc bất kỳ mạng công cộng nào, bạn đã tự đặt mình vào tầm ngắm của một trong những mối đe dọa dai dẳng nhất trên internet: &lt;strong>Tấn công Man-in-the-Middle (MITM)&lt;/strong>.&lt;/p>
&lt;p>Hãy tưởng tượng bạn đang thì thầm một mật khẩu với ngân hàng của mình. Trong một cuộc tấn công MITM, một kẻ lạ mặt đang đứng chính giữa, nghe lén mọi thứ, và thậm chí còn có thể thay đổi tin nhắn của bạn trước khi nó đến đích. Mối đe dọa này không hề xa vời, và hiểu rõ về nó là bước đầu tiên để tự bảo vệ mình.&lt;/p></description></item><item><title>Hệ thống DNS: Thiết kế và Hoạt động</title><link>https://caubechankiu.github.io/posts/dns-system-design-explained/</link><pubDate>Thu, 10 Oct 2024 10:00:00 +0700</pubDate><guid>https://caubechankiu.github.io/posts/dns-system-design-explained/</guid><description>DNS (Domain Name System) là xương sống của internet, nó dịch các tên miền mà con người có thể đọc được, chẳng hạn như google.com, thành các địa chỉ IP mà máy tính có thể hiểu được.</description></item><item><title>HTTPS Hoạt Động Như Thế Nào?</title><link>https://caubechankiu.github.io/posts/how-does-https-work/</link><pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate><guid>https://caubechankiu.github.io/posts/how-does-https-work/</guid><description>&lt;h1 id="https-hoạt-động-như-thế-nào">HTTPS Hoạt Động Như Thế Nào?&lt;/h1>
&lt;p>Ngày nay, hầu hết các website đều yêu cầu HTTPS. Vậy HTTPS hoạt động như thế nào? Chúng ta sẽ trả lời câu hỏi này trong bài viết này.&lt;/p>
&lt;h2 id="vấn-đề-với-http-thông-thường">Vấn Đề Với HTTP Thông Thường&lt;/h2>
&lt;p>Không có HTTPS, việc giao tiếp giữa trình duyệt và server diễn ra dưới dạng văn bản thuần túy. Điều này có nghĩa là mật khẩu bạn nhập hoặc số thẻ tín dụng bạn gửi qua internet có thể được đọc bởi bất kỳ ai có khả năng chặn nó.&lt;/p></description></item><item><title>Transaction Outbox Pattern</title><link>https://caubechankiu.github.io/posts/transaction-outbox-pattern/</link><pubDate>Thu, 21 Dec 2023 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/transaction-outbox-pattern/</guid><description>Transaction Outbox Pattern: Giải pháp đảm bảo tính nhất quán trong hệ thống phân tán</description></item><item><title>Rabbitmq</title><link>https://caubechankiu.github.io/posts/rabbitmq/</link><pubDate>Sun, 17 Dec 2023 23:40:15 +0700</pubDate><guid>https://caubechankiu.github.io/posts/rabbitmq/</guid><description>RabbitMQ là gì, cách nó hoạt động, và làm thế nào nó có thể biến hệ thống của bạn trở nên linh hoạt và đáng tin cậy hơn.</description></item><item><title>What Is A CDN? How Does It Work?</title><link>https://caubechankiu.github.io/posts/what-is-a-cdn-how-does-it-work/</link><pubDate>Wed, 15 Nov 2023 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/what-is-a-cdn-how-does-it-work/</guid><description>CDN, hay mạng phân phối nội dung (Content Delivery Network), đã xuất hiện từ cuối những năm 90. Ban đầu, nó được phát triển để tăng tốc việc phân phối nội dung HTML tĩnh cho người dùng trên toàn thế giới.</description></item><item><title>The Secret Sauce Behind NoSQL: LSM Tree</title><link>https://caubechankiu.github.io/posts/the-secret-sauce-behind-nosql-lsm-tree/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://caubechankiu.github.io/posts/the-secret-sauce-behind-nosql-lsm-tree/</guid><description>Các cơ sở dữ liệu NoSQL như Cassandra đã bùng nổ về độ phổ biến trong những năm gần đây. Một trong những động lực chính là nhu cầu không ngừng về việc tiếp nhận lượng dữ liệu khổng lồ từ ngày càng nhiều nguồn như ứng dụng di động và thiết bị IoT. Bí mật đằng sau nhiều cơ sở dữ liệu NoSQL này là một cấu trúc dữ liệu gọi là Log Structured Merge tree (LSM tree).</description></item><item><title>Caching Pitfalls</title><link>https://caubechankiu.github.io/posts/caching-pitfalls/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://caubechankiu.github.io/posts/caching-pitfalls/</guid><description>Caching là một khái niệm quan trọng trong thiết kế hệ thống, đóng vai trò then chốt cho hiệu suất nhưng cũng có thể gây ra nhiều vấn đề nếu không được xử lý đúng cách.</description></item><item><title>gRPC là gì? Giới thiệu về gRPC</title><link>https://caubechankiu.github.io/posts/what-is-rpc-grpc-introduction/</link><pubDate>Sat, 15 Jul 2023 10:00:00 +0700</pubDate><guid>https://caubechankiu.github.io/posts/what-is-rpc-grpc-introduction/</guid><description>gRPC là một framework RPC (Remote Procedure Call) mã nguồn mở được Google tạo ra vào năm 2016. Đây là phiên bản viết lại của cơ sở hạ tầng RPC nội bộ mà Google đã sử dụng trong nhiều năm.</description></item><item><title>How to store passwords in the database?</title><link>https://caubechankiu.github.io/posts/how-to-store-passwords-in-the-database/</link><pubDate>Sat, 15 Jul 2023 10:00:00 +0700</pubDate><guid>https://caubechankiu.github.io/posts/how-to-store-passwords-in-the-database/</guid><description>Việc lưu trữ mật khẩu một cách an toàn trong cơ sở dữ liệu là một vấn đề quan trọng trong thiết kế hệ thống. Làm thế nào để chúng ta xác thực mật khẩu người dùng nhập vào so với những gì chúng ta lưu trữ trong cơ sở dữ liệu?</description></item><item><title>Load Balancer</title><link>https://caubechankiu.github.io/posts/load-balancer/</link><pubDate>Sat, 04 Mar 2023 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/load-balancer/</guid><description>Trong thế giới hệ thống phân tán và ứng dụng web hiện đại, &lt;strong>Load Balancer (bộ cân bằng tải)&lt;/strong> là một trong những thành phần quan trọng nhất. Nó giúp hệ thống đảm bảo &lt;strong>tính khả dụng cao (high availability)&lt;/strong>, &lt;strong>hiệu suất tối ưu (performance)&lt;/strong> và &lt;strong>khả năng mở rộng (scalability)&lt;/strong>.</description></item><item><title>Saga Pattern</title><link>https://caubechankiu.github.io/posts/saga-pattern/</link><pubDate>Wed, 01 Feb 2023 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/saga-pattern/</guid><description>Saga Pattern là một mẫu thiết kế (design pattern) dùng để quản lý giao dịch giữa nhiều service độc lập trong kiến trúc microservices</description></item><item><title>Git merge vs rebase</title><link>https://caubechankiu.github.io/posts/git-merge-and-rebase/</link><pubDate>Sat, 17 Dec 2022 10:43:32 +0700</pubDate><guid>https://caubechankiu.github.io/posts/git-merge-and-rebase/</guid><description>Nếu bạn từng làm việc trên một dự án Git có nhiều branch, có lẽ bạn đã từng phải tìm cách đưa các thay đổi từ feature branch về lại main branch, hoặc giữ cho feature branch luôn được cập nhật từ main branch. Giờ nên xài &lt;code>git merge&lt;/code>, &lt;code>git rebase&lt;/code> hay &lt;code>squash commit&lt;/code>?</description></item><item><title>ACID</title><link>https://caubechankiu.github.io/posts/acid/</link><pubDate>Thu, 07 Jul 2022 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/acid/</guid><description>ACID là viết tắt của Atomicity, Consistency, Isolation và Durability - bốn thuộc tính quan trọng đảm bảo các transaction trong database đáng tin cậy, ngay cả khi có sự cố xảy ra.</description></item><item><title>Rate Limiting</title><link>https://caubechankiu.github.io/posts/rate-limiting/</link><pubDate>Fri, 17 Dec 2021 23:40:15 +0700</pubDate><guid>https://caubechankiu.github.io/posts/rate-limiting/</guid><description>Rate Limiting (giới hạn tốc độ truy cập) là một kỹ thuật kiểm soát số lượng request mà một client có thể gửi đến một hệ thống trong một khoảng thời gian nhất định.</description></item><item><title>HTTP 1 Vs HTTP 2!</title><link>https://caubechankiu.github.io/posts/http-1-vs-http-2/</link><pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate><guid>https://caubechankiu.github.io/posts/http-1-vs-http-2/</guid><description>Hôm nay chúng ta sẽ đi sâu vào thế giới thú vị của HTTP - xương sống của web. Chúng ta sẽ khám phá cách nó phát triển từ HTTP 1 đến HTTP 2.</description></item><item><title>CAP Theorem</title><link>https://caubechankiu.github.io/posts/cap-theorem/</link><pubDate>Fri, 02 Apr 2021 10:43:32 +0700</pubDate><guid>https://caubechankiu.github.io/posts/cap-theorem/</guid><description>Hiểu đúng về sự đánh đổi trong hệ thống phân tán. Định lý CAP (CAP Theorem) là một nguyên tắc quan trọng trong lĩnh vực hệ thống phân tán, được nhà khoa học máy tính Eric Brewer đề xuất vào năm 2000</description></item><item><title>Circuit Breaker and Retry</title><link>https://caubechankiu.github.io/posts/circuit-breaker-and-retry/</link><pubDate>Sat, 20 Feb 2021 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/circuit-breaker-and-retry/</guid><description>Circuit breaker và retry là hai cơ chế quan trọng giúp tăng cường độ tin cậy và khả năng chịu lỗi của hệ thống.</description></item><item><title>Idempotency</title><link>https://caubechankiu.github.io/posts/idempotent/</link><pubDate>Tue, 09 Feb 2021 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/idempotent/</guid><description>Tính bất biến là gì và làm thế nào để sử dụng nó một cách hợp lý</description></item><item><title>Bloom Filter</title><link>https://caubechankiu.github.io/posts/bloom-filter/</link><pubDate>Wed, 14 Oct 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/bloom-filter/</guid><description>Nếu bạn từng nghe đến các cấu trúc dữ liệu như &lt;strong>Hash Table&lt;/strong> hay &lt;strong>Binary Search Tree&lt;/strong>, thì &lt;strong>Bloom Filter&lt;/strong> có thể là một khái niệm thú vị tiếp theo để khám phá.</description></item><item><title>Consistent Hashing</title><link>https://caubechankiu.github.io/posts/consistent-hashing/</link><pubDate>Wed, 01 Apr 2020 10:43:32 +0700</pubDate><guid>https://caubechankiu.github.io/posts/consistent-hashing/</guid><description>Trong các hệ thống phân tán như caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB), việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng.</description></item><item><title>Optimistic Lock vs Pessimistic Lock</title><link>https://caubechankiu.github.io/posts/optimistic-lock-vs-pessimistic-lock/</link><pubDate>Wed, 04 Mar 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/optimistic-lock-vs-pessimistic-lock/</guid><description>Trong quản lý giao dịch và cạnh tranh truy cập dữ liệu, có hai chiến lược chính để kiểm soát tính nhất quán: &lt;strong>Optimistic Lock&lt;/strong> và &lt;strong>Pessimistic Lock&lt;/strong>. Mỗi loại có cách tiếp cận khác nhau trong việc xử lý xung đột dữ liệu. Bài viết này sẽ phân tích chi tiết hai loại lock này, đồng thời giải thích hai dạng của &lt;strong>Pessimistic Lock&lt;/strong> là &lt;strong>Shared Lock&lt;/strong> và &lt;strong>Exclusive Lock&lt;/strong>.</description></item><item><title>Session vs Jwt</title><link>https://caubechankiu.github.io/posts/session-vs-jwt/</link><pubDate>Sat, 01 Feb 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/session-vs-jwt/</guid><description>Session-based authentication vs JSON Web Tokens (JWTs)</description></item><item><title>Distributed ID generator</title><link>https://caubechankiu.github.io/posts/distributed-id-generator/</link><pubDate>Sat, 25 Jan 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/distributed-id-generator/</guid><description>Nguồn mình copy nguyên văn ở &lt;a href="https://zalopay-oss.github.io/go-advanced/ch5-distributed-system/ch5-01-dist-id.html">zalo-go-advanced&lt;/a> và không sửa gì cả. Trong bài viết gốc còn nhiều kiến thức thú vị hơn. Đôi khi chúng ta cần tạo ra một ID tương tự như ID tăng tự động của MySQL và có tính chất không được trùng lặp. Chúng ta có thể sử dụng ID để hỗ trợ các ngữ cảnh trong kinh doanh. Điển hình, khi có chương trình khuyến mãi trong thương mại điện tử, một số lượng lớn đơn đặt hàng sẽ tràn vào hệ thống trong một khoảng thời gian ngắn, tạo ra khoảng 10 ngàn đơn mỗi giây, mỗi đơn sẽ tương ứng với một ID định danh.</description></item><item><title>Concurrency vs Parallelism</title><link>https://caubechankiu.github.io/posts/concurrency-parallelism/</link><pubDate>Mon, 20 Jan 2020 09:47:31 +0700</pubDate><guid>https://caubechankiu.github.io/posts/concurrency-parallelism/</guid><description>Mô hình lập trình đồng thời và lập trình song song</description></item></channel></rss>