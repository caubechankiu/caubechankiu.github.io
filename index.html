<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>caubechankiu's miscellaneous notes | Home </title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:image" content><link rel=alternate type=application/rss+xml href=https://caubechankiu.github.io/index.xml title="caubechankiu's miscellaneous notes"><meta property="og:url" content="https://caubechankiu.github.io/"><meta property="og:site_name" content="caubechankiu's miscellaneous notes"><meta property="og:title" content="caubechankiu's miscellaneous notes"><meta property="og:locale" content="vi_VN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="caubechankiu's miscellaneous notes"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://caubechankiu.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css disabled><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=stylesheet type=text/css href=https://caubechankiu.github.io/css/archie.90f4a1321261c2df9485c29a7877582160bb95d018fefaa5f2199bccf7b169f5.css></head><body><div class=content><header><div class=main><a href=https://caubechankiu.github.io/>caubechankiu's miscellaneous notes</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/tags>Tags</a>
| <span id=dark-mode-toggle onclick=toggleTheme()><svg class="feather"><use href="https://unpkg.com/feather-icons@4.29.2/dist/feather-sprite.svg#sun"/></svg></span>
<script src=https://caubechankiu.github.io/js/themetoggle.js></script></nav></header><main class=list><div class=site-description></div><section class=list-item><h1 class=title><a href=/posts/transaction-outbox-pattern/>Transaction Outbox Pattern</a></h1><time>Dec 21, 2023</time><br><div class=description>Transaction Outbox Pattern: Giải pháp đảm bảo tính nhất quán trong hệ thống phân tán&mldr;</div><a class=readmore href=/posts/transaction-outbox-pattern/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/rate-limiting/>Rate Limiting</a></h1><time>Dec 17, 2021</time><br><div class=description>Rate Limiting (giới hạn tốc độ truy cập) là một kỹ thuật kiểm soát số lượng request mà một client có thể gửi đến một hệ thống trong một khoảng thời gian nhất định.&mldr;</div><a class=readmore href=/posts/rate-limiting/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/cap-theorem/>CAP Theorem</a></h1><time>Apr 2, 2021</time><br><div class=description>Hiểu đúng về sự đánh đổi trong hệ thống phân tán. Định lý CAP (CAP Theorem) là một nguyên tắc quan trọng trong lĩnh vực hệ thống phân tán, được nhà khoa học máy tính Eric Brewer đề xuất vào năm 2000&mldr;</div><a class=readmore href=/posts/cap-theorem/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/circuit-breaker-and-retry/>Circuit Breaker and Retry</a></h1><time>Feb 20, 2021</time><br><div class=description>Circuit breaker và retry là hai cơ chế quan trọng giúp tăng cường độ tin cậy và khả năng chịu lỗi của hệ thống.&mldr;</div><a class=readmore href=/posts/circuit-breaker-and-retry/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/idempotency/>Idempotency</a></h1><time>Feb 9, 2021</time><br><div class=description>Tính bất biến là gì và làm thế nào để sử dụng nó một cách hợp lý&mldr;</div><a class=readmore href=/posts/idempotency/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/bloom-filter/>Bloom Filter</a></h1><time>Oct 14, 2020</time><br><div class=description>Nếu bạn từng nghe đến các cấu trúc dữ liệu như <strong>Hash Table</strong> hay <strong>Binary Search Tree</strong>, thì <strong>Bloom Filter</strong> có thể là một khái niệm thú vị tiếp theo để khám phá.&mldr;</div><a class=readmore href=/posts/bloom-filter/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/consistent-hashing/>Consistent Hashing</a></h1><time>Apr 1, 2020</time><br><div class=description>Trong các hệ thống phân tán như caching (Redis, Memcached), load balancing, distributed databases (Cassandra, DynamoDB), việc phân phối dữ liệu một cách hiệu quả giữa các node là một bài toán quan trọng.&mldr;</div><a class=readmore href=/posts/consistent-hashing/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/optimistic-lock-vs-pessimistic-lock/>Optimistic Lock vs Pessimistic Lock</a></h1><time>Mar 4, 2020</time><br><div class=description>Trong quản lý giao dịch và cạnh tranh truy cập dữ liệu, có hai chiến lược chính để kiểm soát tính nhất quán: <strong>Optimistic Lock</strong> và <strong>Pessimistic Lock</strong>. Mỗi loại có cách tiếp cận khác nhau trong việc xử lý xung đột dữ liệu. Bài viết này sẽ phân tích chi tiết hai loại lock này, đồng thời giải thích hai dạng của <strong>Pessimistic Lock</strong> là <strong>Shared Lock</strong> và <strong>Exclusive Lock</strong>.&mldr;</div><a class=readmore href=/posts/optimistic-lock-vs-pessimistic-lock/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/session-vs-jwt/>Session vs Jwt</a></h1><time>Feb 1, 2020</time><br><div class=description>Session-based authentication vs JSON Web Tokens (JWTs)&mldr;</div><a class=readmore href=/posts/session-vs-jwt/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/distributed-id-generator/>Distributed ID generator</a></h1><time>Jan 25, 2020</time><br><div class=description>Nguồn mình copy nguyên văn ở <a href=https://zalopay-oss.github.io/go-advanced/ch5-distributed-system/ch5-01-dist-id.html>zalo-go-advanced</a> và không sửa gì cả. Trong bài viết gốc còn nhiều kiến thức thú vị hơn. Đôi khi chúng ta cần tạo ra một ID tương tự như ID tăng tự động của MySQL và có tính chất không được trùng lặp. Chúng ta có thể sử dụng ID để hỗ trợ các ngữ cảnh trong kinh doanh. Điển hình, khi có chương trình khuyến mãi trong thương mại điện tử, một số lượng lớn đơn đặt hàng sẽ tràn vào hệ thống trong một khoảng thời gian ngắn, tạo ra khoảng 10 ngàn đơn mỗi giây, mỗi đơn sẽ tương ứng với một ID định danh.&mldr;</div><a class=readmore href=/posts/distributed-id-generator/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"></span><span class="page-item page-next"><a href=/page/2/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><div style=display:flex><a class=soc href=https://github.com/caubechankiu rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.facebook.com/trinhthevils rel=me title=Facebook><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#facebook"/></svg></a><a class=border></a></div><div class=footer-info>2025 © caubechankiu | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>